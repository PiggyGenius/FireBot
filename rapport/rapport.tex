\documentclass[12pt,a4paper]{article}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[top=1cm,bottom=1cm,right=1cm,left=1cm]{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   Page de garde   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% variable à redéfinir (placées sur la page de garde et sur l'entête)
\def\typedeprojet{Projet de POO}
\def\nomduprojet{Simulation de robots pompiers}
\def\dateduprojet{15 novembre 2016}

% définition des entêtes et pieds de page
\pagestyle{fancy}

% définition des marges pour les entêtes et pieds de page
\renewcommand{\headrulewidth}{0.1pt}
\renewcommand{\footrulewidth}{0.1pt}

% entête de page
\lhead{\includegraphics[height=1.2cm]{rapport/logo_ensimag.jpg}}
\chead{\bf \typedeprojet}
\rhead{\nomduprojet}

% pied de page
\lfoot{\LaTeX}
\cfoot{}
\rfoot{\thepage}

% compte à partir de 0 => la 2e page est donc à 1
\setcounter{page}{0}

% re-définition des tailles d'entête et de texte
\setlength{\headheight}{60pt}
\setlength{\textheight}{710pt}

% titre de la page de garde
\title{
	% illustrations
	\begin{flushleft}
		\includegraphics[width=5cm]{rapport/logo_ensimag.jpg} \hfill
		\includegraphics[width=7cm]{rapport/firebot.jpg} \\[40pt]
	\end{flushleft} 
	% séparateur 1
	{\rule{15cm}{1mm}}\vspace{7mm}
	% titres
	\begin{tabular}{p{4cm} r}
		& {\Huge {\bf \typedeprojet}} \\[20pt]
		& {\huge \nomduprojet}
	\end{tabular}\\
	% séparateur 2
	\vspace{7mm}{\rule{15cm}{1mm}}\vspace{2mm} \\
	% date
	\hfill \large \dateduprojet \hspace{2cm}
	% table des matières
	\renewcommand{\contentsname}{\LARGE \it Sommaire \hfill} % renommage de la table
	\setcounter{tocdepth}{2} % numérotation (1 pour les sections, 2 pour les sous-sections, ...)
	\tableofcontents
	\vfill
}

% auteur(s)
\author{
	\begin{tabular}{p{15cm}}
		\Large Maxime Deloche, Ludovic Carré \& Cyril Carlin
	\end{tabular} \\
	\hline
}

% pas de date, elle est dans le titre
\date{}

\begin{document}
\maketitle
\thispagestyle{empty} % pas de numérotation de la page de garde
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -------------------------------------- SECTION 1 --------------------------------------

\section{Description des packages intéressants}

\subsection{Chemin}

Le package chemin a pour rôle de définir les différentes classes nécessaires à la partie 3 du projet. On a choisi de créer une classe abstraite PlusCourtChemin qui permet une abstraction sur les stratégies de calculs de plus court chemin employées. Nous avons pour l'instant implémenté un seul algorithme, Dijkstra, mais il serait facile de rajouter une classe pour un autre algorithme comme A* sans avoir à modifier le reste du code.\\

Nous avons hésité entre Dijkstra et A* et finalement choisi Dijkstra car A* ne semblait pas vraiment nécessaire au problème traité. Les cartes sont relativement petites ce qui implique un nombre de noeud assez restreint, 2500 pour la plus grande carte. De plus, il serait difficile de définir une bonne heuristique puisqu'il n'y a pas d'information sur la structure "normale" d'une carte.

\subsubsection{Dijkstra avec un hash set}

On notera $N = n*m$, où n et m sont les dimensions de la carte, le nombre de noeuds et les complexités sont calculées en pire cas (aucun noeud inaccessible dans le graphe).
\begin{itemize}
	\item setEnsembleNoeud: Initialise le HashSet avec les noeuds sur lesquels itérer. Coût: $\theta(N)$.
	\item initDistance: Initialise le tableau de distance à $+\infty$. Coût: $\theta(N)$.
	\item getMin: Retourne le noeud non exploré le plus proche de la source. Coût: $\sum\limits_{i=0}^{N}{N-i} = \frac{N(N-1)}{2} = \theta(N^2)$.
	\item setDistanceVoisins: Met à jour les distances du tableau avec les distances des voisins. Coût: $4N-4 = \theta(N)$.\\
\end{itemize}
Complexité générale de l'algorithme: $\theta(N^2)$.\\\\
La Complexité assez élevée et l'on a donc décidé d'améliorer l'algorithme avec une pile de Fibonacci ce qui permet d'atteindre la complexitée optimale en $\theta(4N-4 + Nlog_2(N))$. Malheureusement, nous avons visés un peut trop haut avec une implémentation générique de la pile de Fibonacci ce qui a beaucoup compliqué le code et l'échéance approchant on a décidé de se reporter sur une solution plus simple mais qui reste très respectable: la file de priorité.\\

\subsubsection{Dijkstra avec une priority queue}
Il est possible d'améliorer l'algorithme en utilisant une priority queue comme structure de données. Pour cela il faut rajouter une abstraction Noeud qui contient un poids et une case, la liste est constamment ordonnée tel que l'élément de poids minimale est le premier élément de la liste, ce qui améliore la complexité de l'algorithme car la priority queue est implémentée avec un tas binaire en Java.\\
De plus, afin d'encore améliorer la rapidité de l'algorithme, nous traitons un ensemble de noeud ne contenant que la source au départ qui se remplit au fur et à mesure des détections de voisins ce qui permet de diminuer les coefficients des différentes étapes de l'algorithme. On note $N_i=i*4-i$ le nombre de noeud à l'iteration i de l'algoritme.
\begin{itemize}
	\item stockCarte: La nouvelle version de l'algorithme créée un tableau de noeud constitué des cases de la carte lors de la création de l'objet. Coût: $\theta(N)$.
	\item setEnsembleNoeud: Il faut initialiser tous les noeuds avec un poids à $+\inf$ et un prédecesseur à null. Coût: $\theta(N)$.
	\item getMin: La fonction à disparue il s'agit simplement de l'extraction de la tête de la file de priorité. Trouver le min de la file est en $\theta(1)$ puisqu'il s'agit de la tête, cependant il faut déterminer la nouvelle tête de file après l'extraction. Dans un tas binaire, l'opération se fait par swapping jusqu'a obtenir le min en racine. Coût: $\theta(log_2(N)$.
\end{itemize}
Complexité générale de l'algorithme: $\theta(Nlog_2(N))$.\\

\subsubsection{Reconstruction du chemin avec le tableau de prédecesseur}

On définit un chemin comme un hash set de Destination, à chaque objet est associé une position et un temps de trajet pour s'y rendre en partant de la source, et un temps qui est la somme des temps des sous-trajets.\\
Puisqu'il s'agit d'un hash set, il n'y a pas de notion d'ordre dans un chemin ce qui peut sembler particulier mais puisque les événements sont ajoutés avec un temps d'exécution, l'ordre n'est pas nécessaire.\\\\
\textbf{Algorithme de reconstruction de Dijkstra:} L'algorithme consiste simplement à reconstruire le chemin à partir du tableau de prédécesseurs créé lors des mises à jours de distance.\\
Coût: $\theta(M)$ où $M$ est la longueur du chemin en nombre de case donc $\theta(N-1)$ en pire cas.




\subsection{Simulation et evenements}

\verb?evenement? est un sous-package de \verb?simulation?.

\subsubsection{ChefPompier}

Le ChefPompier est chargé de planifier la liste des évènements. Pour cela, il possède plusieurs méthodes, qui sont appelées lorsque les évènements sont exécutés. Un cycle d'intervention d'un robot sur un incendie se déroule comme suit : 
\begin{enumerate}
	\item A chaque pas de temps, la fonction \verb?calculDeplacementExtinction? parcourt la liste des incendies, et cherche pour chacun dans la liste des robots disponibles le plus rapide à intervenir. Elle envoit ensuite ce robot à cet emplacement, donc planifie une séquence d'\verb?EvenementDeplacement? élémentaires et un évènement \verb?EvenementDeplacementFin?.
	\item Lorque ce \verb?EvenementDeplacementFin? est éxécuté, le \verb?ChefPompier? calcule le nombre de déversements maximum possible, et planifie des \verb?EvenementDeversement? et un \verb?EvenementDeversementFin?.
	\item Lorsque cet évènement \verb?EvenementDeversementFin? est éxécuté, le \verb?ChefPompier? calcule le plus court chemin pour remplir le robot, et planifie à nouveau une série \verb?EvenementDeplacement? et un autre \verb?EvenementDeplacementFin?. Si le robot n'a pas besoin de remplissage, il repasse immédiatement à 'libre' et sera affecté à un nouvel incendie au prochain pas de temps.
	\item Lorsque cet évènement \verb?EvenementDeplacementFin? est éxécuté, il planifie un \verb?EvenementRemplissage? et un \verb?EvenementRemplissageFin?.
	\item Lorsque cet évènement \verb?EvenementRemplissageFin? est éxécuté, le robot est libéré et sera affecté à un nouvel incendie au prochain pas de temps.
\end{enumerate}

NB : Dans les \verb?EvenementDeplacementFin?, un attribut sert à indiquer si c'est un évènement pour un déversement ou un remplissage, et permet au \verb?ChefPompier? d'"aiguiller" la suite de la procédure.

% -------------------------------------- SECTION 2 --------------------------------------

\section{}

\subsection{}

\subsection{}


% -------------------------------------- SECTION 3 --------------------------------------

\section{}

\subsection{}

\subsection{}


\end{document}
